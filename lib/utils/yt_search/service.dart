import 'dart:convert';
import 'package:dio/dio.dart';
import '../connectivity_helper.dart';
import '../../l10n/locale_provider.dart';

CancelToken? _searchCancelToken;

const domain = "https://music.youtube.com/";
const String baseUrl = '${domain}youtubei/v1/';
const fixedParms =
    '?prettyPrint=false&alt=json&key=AIzaSyC9XL3ZjWddXya6X74dJoCTL-WEYFDNX30';
const userAgent =
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36';

final Map<String, String> headers = {
  'user-agent': userAgent,
  'accept': '*/*',
  'accept-encoding': 'gzip, deflate',
  'content-type': 'application/json',
  'content-encoding': 'gzip',
  'origin': domain,
  'cookie': 'CONSENT=YES+1',
};

final Map<String, dynamic> ytServiceContext = {
  'context': {
    'client': {"clientName": "WEB_REMIX", "clientVersion": "1.20230213.01.00"},
    'user': {},
  },
};

class YtMusicResult {
  final String? title;
  final String? artist;
  final String? thumbUrl;
  final String? videoId;

  YtMusicResult({this.title, this.artist, this.thumbUrl, this.videoId});
}

// B√∫squeda recursiva de una clave dentro de un √°rbol Map/List
dynamic _findObjectByKey(dynamic node, String key) {
  if (node == null) return null;
  if (node is Map) {
    if (node.containsKey(key)) return node[key];
    for (final v in node.values) {
      final found = _findObjectByKey(v, key);
      if (found != null) return found;
    }
  } else if (node is List) {
    for (final item in node) {
      final found = _findObjectByKey(item, key);
      if (found != null) return found;
    }
  }
  return null;
}

// Obtiene informaci√≥n detallada de un artista usando su browseId
Future<Map<String, dynamic>?> getArtistDetails(String browseId) async {
  String normalizedId = browseId;
  if (normalizedId.startsWith('MPLA')) {
    normalizedId = normalizedId.substring(4);
  }

  final data = {
    ...ytServiceContext,
    'browseId': normalizedId,
  };
  // Configurar idioma seg√∫n la configuraci√≥n de la app
  try {
    final ctx = (data['context'] as Map);
    final client = (ctx['client'] as Map);
    // Usar espa√±ol si est√° disponible, sino ingl√©s como fallback
    final locale = languageNotifier.value;
    client['hl'] = locale.startsWith('es') ? 'es' : 'en';
  } catch (_) {}

  try {
    final response = (await sendRequest("browse", data)).data;

    // Header de artista
    final header = nav(response, ['header', 'musicImmersiveHeaderRenderer']) ??
        nav(response, ['header', 'musicVisualHeaderRenderer']);

    String? name = header != null ? nav(header, ['title', 'runs', 0, 'text']) : null;

    // results: pesta√±a single column
    final results = nav(response, [
      'contents',
      'singleColumnBrowseResultsRenderer',
      'tabs',
      0,
      'tabRenderer',
      'content',
      'sectionListRenderer',
      'contents',
    ]);

    String? description;
    if (results != null) {
      final descRenderer = _findObjectByKey(results, 'musicDescriptionShelfRenderer');
      if (descRenderer is Map) {
        final runs = nav(descRenderer, ['description', 'runs']);
        if (runs is List && runs.isNotEmpty) {
          description = runs.map((r) => r['text']).whereType<String>().join('');
        }
      }
    }

    // Suscriptores
    String? subscribers = header != null
        ? nav(header, [
            'subscriptionButton',
            'subscribeButtonRenderer',
            'subscriberCountText',
            'runs',
            0,
            'text'
          ])
        : null;

    // Thumbnail - buscar en m√∫ltiples ubicaciones para obtener la mejor imagen
    String? thumbUrl;
    if (header != null) {
      // Primera opci√≥n: musicThumbnailRenderer (imagen completa)
      var thumbnails = nav(header, [
        'thumbnail',
        'musicThumbnailRenderer',
        'thumbnail',
        'thumbnails'
      ]);
      
      // Segunda opci√≥n: croppedSquareThumbnailRenderer (imagen cuadrada recortada)
      thumbnails ??= nav(header, [
        'thumbnail',
        'croppedSquareThumbnailRenderer',
        'thumbnail',
        'thumbnails'
      ]);
      
      // Tercera opci√≥n: buscar en cualquier estructura de thumbnail
      if (thumbnails == null) {
        final thumbnail = nav(header, ['thumbnail']);
        if (thumbnail is Map) {
          for (var key in thumbnail.keys) {
            final subThumb = thumbnail[key];
            if (subThumb is Map && subThumb.containsKey('thumbnails')) {
              thumbnails = subThumb['thumbnails'];
              break;
            }
          }
        }
      }
      
      if (thumbnails is List && thumbnails.isNotEmpty) {
        // Usar la imagen de mayor resoluci√≥n disponible
        thumbUrl = thumbnails.last['url'];
        
        // Si la URL contiene par√°metros de recorte, intentar obtener una sin recortar
        if (thumbUrl != null && thumbUrl.contains('w120-h120')) {
          // Intentar obtener una imagen de mayor tama√±o
          for (var i = thumbnails.length - 1; i >= 0; i--) {
            final url = thumbnails[i]['url'];
            if (url != null && !url.contains('w120-h120')) {
              thumbUrl = url;
              break;
            }
          }
        }
        
        // Limpiar par√°metros de recorte de la URL si es necesario
        if (thumbUrl != null) {
          thumbUrl = _cleanThumbnailUrl(thumbUrl);
        }
      }
    }

    // Debug prints
    /*
    if (description != null && description.trim().isNotEmpty) {
      print('üëª YT Artist description ($normalizedId): '
          '${description.substring(0, description.length.clamp(0, 400))}'
          '${description.length > 400 ? '‚Ä¶' : ''}');
    } else {
      print('üëª YT Artist description not found for $normalizedId');
    }
    */

    return {
      'name': name,
      'description': description,
      'thumbUrl': thumbUrl,
      'subscribers': subscribers,
      'browseId': normalizedId,
    };
  } catch (_) {
    return null;
  }
}

// Helper: busca por nombre y devuelve info detallada del primer artista
Future<Map<String, dynamic>?> getArtistInfoByName(String name) async {
  try {
    final results = await searchArtists(name, limit: 1);
    if (results.isEmpty) return null;
    final first = results.first;
    final browseId = first['browseId'];
    if (browseId == null) return null;
    return await getArtistDetails(browseId);
  } catch (_) {
    return null;
  }
}

// Helper: limpia par√°metros de recorte de URLs de thumbnails
String _cleanThumbnailUrl(String url) {
  // Remover par√°metros de recorte comunes
  url = url.replaceAll(RegExp(r'[?&]w\d+-h\d+'), '');
  url = url.replaceAll(RegExp(r'[?&]crop=\d+'), '');
  url = url.replaceAll(RegExp(r'[?&]rs=\d+'), '');
  
  // Limpiar par√°metros dobles
  url = url.replaceAll(RegExp(r'[?&]{2,}'), '&');
  url = url.replaceAll(RegExp(r'[?&]$'), '');
  
  // Si queda solo ?, removerlo
  if (url.endsWith('?')) {
    url = url.substring(0, url.length - 1);
  }
  
  return url;
}

// ===== Wikipedia Fallback =====
List<String> _getArtistNameVariations(String name) {
  // Variaciones gen√©ricas para cualquier artista, ordenadas por probabilidad de √©xito
  // Las m√°s comunes aparecen primero para optimizar las llamadas a la API
  return [
    '$name (cantante)',
    '$name (artista)',
    '$name (m√∫sico)',
    '$name (m√∫sica)',
    '$name (banda)',
    '$name (grupo musical)',
    '$name (cantante mexicano)',
    '$name (cantante mexicana)',
    '$name (cantante estadounidense)',
    '$name (cantante espa√±ol)',
    '$name (cantante espa√±ola)',
    '$name (cantante colombiano)',
    '$name (cantante colombiana)',
    '$name (cantante argentino)',
    '$name (cantante argentina)',
    '$name (cantante venezolano)',
    '$name (cantante venezolana)',
    '$name (cantante puertorrique√±o)',
    '$name (cantante puertorrique√±a)',
    '$name (cantante cubano)',
    '$name (cantante cubana)',
    '$name (cantante chileno)',
    '$name (cantante chilena)',
    '$name (cantante peruano)',
    '$name (cantante peruana)',
  ];
}

Future<String?> _getWikipediaSummary(String title, {String lang = 'es'}) async {
  try {
    final dio = Dio();
    final encoded = Uri.encodeComponent(title);
    final url = 'https://$lang.wikipedia.org/api/rest_v1/page/summary/$encoded';
    final res = await dio.get(
      url,
      options: Options(
        headers: {
          'accept': 'application/json',
          'user-agent': userAgent,
        },
        validateStatus: (s) => s != null && s >= 200 && s < 500,
      ),
    );
    if (res.statusCode == 200 && res.data is Map) {
      final map = res.data as Map;
      
      // Verificar si es una p√°gina de desambiguaci√≥n
      final type = map['type']?.toString();
      if (type == 'disambiguation') {
        
        // Intentar variaciones m√°s espec√≠ficas para artistas
        final variations = _getArtistNameVariations(title);
        
        // Limitar a las primeras 10 variaciones m√°s probables para evitar demasiadas llamadas
        final limitedVariations = variations.take(10).toList();
        
        for (final variation in limitedVariations) {
          final variationResult = await _getWikipediaSummary(variation, lang: lang);
          if (variationResult != null && variationResult.trim().isNotEmpty) {
            return variationResult;
          }
        }
        
        // Si no se encuentra ninguna variaci√≥n espec√≠fica, devolver null
        return null;
      }
      
      final extract = map['extract']?.toString();
      if (extract != null && extract.trim().isNotEmpty) {
        return extract;
      }
    }
  } catch (_) {}
  return null;
}

Future<String?> getArtistWikipediaDescription(String name) async {
  // Obtener el idioma actual de la app
  final currentLang = languageNotifier.value;
  final wikiLang = currentLang == 'en' ? 'en' : 'es';
  
  String? desc = await _getWikipediaSummary(name, lang: wikiLang);
  /*
  if (desc != null && desc.trim().isNotEmpty) {
    // ignore: avoid_print
    print('üëª Wikipedia $wikiLang description for "$name": '
        '${desc.substring(0, desc.length.clamp(0, 300))}${desc.length > 300 ? '‚Ä¶' : ''}');
    return desc;
  }
  */
  // Si no se encuentra en el idioma principal, intentar con el idioma alternativo
  if (desc == null || desc.trim().isEmpty) {
    final fallbackLang = currentLang == 'en' ? 'es' : 'en';
    desc = await _getWikipediaSummary(name, lang: fallbackLang);
    /*
    if (desc != null && desc.trim().isNotEmpty) {
      // ignore: avoid_print
      print('üëª Wikipedia $fallbackLang fallback description for "$name": '
          '${desc.substring(0, desc.length.clamp(0, 300))}${desc.length > 300 ? '‚Ä¶' : ''}');
    } else {
      // ignore: avoid_print
      print('üëª Wikipedia description not found for "$name" ($wikiLang/$fallbackLang)');
    }
    */
  }
  return desc;
}

// Funci√≥n para generar par√°metros de b√∫squeda espec√≠ficos para canciones
String? getSearchParams(String? filter, String? scope, bool ignoreSpelling) {
  String filteredParam1 = 'EgWKAQI';
  String? params;
  String? param1;
  String? param2;
  String? param3;

  if (filter == null && scope == null && !ignoreSpelling) {
    return params;
  }

  if (scope == null && filter != null) {
    if (filter == 'playlists') {
      params = 'Eg-KAQwIABAAGAAgACgB';
      if (!ignoreSpelling) {
        params += 'MABqChAEEAMQCRAFEAo%3D';
      } else {
        params += 'MABCAggBagoQBBADEAkQBRAK';
      }
    } else if (filter.contains('playlists')) {
      param1 = 'EgeKAQQoA';
      if (filter == 'featured_playlists') {
        param2 = 'Dg';
      } else {
        param2 = 'EA';
      }
      if (!ignoreSpelling) {
        param3 = 'BagwQDhAKEAMQBBAJEAU%3D';
      } else {
        param3 = 'BQgIIAWoMEA4QChADEAQQCRAF';
      }
    } else {
      param1 = filteredParam1;
      param2 = _getParam2(filter);
      if (!ignoreSpelling) {
        param3 = 'AWoMEA4QChADEAQQCRAF';
      } else {
        param3 = 'AUICCAFqDBAOEAoQAxAEEAkQBQ%3D%3D';
      }
    }
  }

  if (scope == null && filter == null && ignoreSpelling) {
    params = 'EhGKAQ4IARABGAEgASgAOAFAAUICCAE%3D';
  }

  return params ?? (param1! + param2! + param3!);
}

// Funci√≥n para generar par√°metros con l√≠mite de resultados
String? getSearchParamsWithLimit(String? filter, String? scope, bool ignoreSpelling, {int limit = 50}) {
  final baseParams = getSearchParams(filter, scope, ignoreSpelling);
  if (baseParams == null) return null;
  
  // Agregar par√°metro de l√≠mite si es necesario
  // YouTube Music usa diferentes par√°metros para controlar el n√∫mero de resultados
  return baseParams;
}

String? _getParam2(String filter) {
  final filterParams = {
    'songs': 'I',      // Par√°metro espec√≠fico para canciones
    'videos': 'Q',
    'albums': 'Y',
    'artists': 'g',
    'playlists': 'o'
  };
  return filterParams[filter];
}

// Funci√≥n utilitaria para navegar el JSON
dynamic nav(dynamic data, List<dynamic> path) {
  dynamic current = data;
  for (final key in path) {
    if (current == null) return null;
    if (key is int) {
      if (current is List && key < current.length) {
        current = current[key];
      } else {
        return null;
      }
    } else if (key is String) {
      if (current is Map && current.containsKey(key)) {
        current = current[key];
      } else {
        return null;
      }
    }
  }
  return current;
}

// Funci√≥n para enviar la petici√≥n
Future<Response> sendRequest(String action, Map<dynamic, dynamic> data, {String additionalParams = "", CancelToken? cancelToken}) async {
  // Verificar conectividad antes de hacer la petici√≥n
  final hasConnection = await ConnectivityHelper.hasInternetConnectionWithTimeout(
    timeout: const Duration(seconds: 5),
  );
  
  if (!hasConnection) {
    throw DioException(
      requestOptions: RequestOptions(path: ''),
      error: 'No hay conexi√≥n a internet',
      type: DioExceptionType.connectionError,
    );
  }

  final dio = Dio();
  final url = "$baseUrl$action$fixedParms$additionalParams";
  return await dio.post(
    url,
    options: Options(
      headers: headers,
      validateStatus: (status) {
        return (status != null && (status >= 200 && status < 300)) || status == 400;
      },
    ),
    data: jsonEncode(data),
    cancelToken: cancelToken,
  );
}

// Funci√≥n para parsear canciones espec√≠ficamente
void parseSongs(List items, List<YtMusicResult> results) {
  for (var item in items) {
    final renderer = item['musicResponsiveListItemRenderer'];
    if (renderer != null) {
      // Verificar si es una canci√≥n (no un video)
      final videoType = nav(renderer, [
        'overlay',
        'musicItemThumbnailOverlayRenderer',
        'content',
        'musicPlayButtonRenderer',
        'playNavigationEndpoint',
        'watchEndpoint',
        'watchEndpointMusicSupportedConfigs',
        'watchEndpointMusicConfig',
        'musicVideoType'
      ]);
      
      // Solo procesar si es una canci√≥n (MUSIC_VIDEO_TYPE_ATV) o si no hay tipo espec√≠fico
      if (videoType == null || videoType == 'MUSIC_VIDEO_TYPE_ATV') {
        final title = renderer['flexColumns']?[0]
            ?['musicResponsiveListItemFlexColumnRenderer']?['text']?['runs']?[0]?['text'];

        final subtitleRuns = renderer['flexColumns']?[1]
            ?['musicResponsiveListItemFlexColumnRenderer']?['text']?['runs'];
        String? artist;
        if (subtitleRuns is List) {
          for (var run in subtitleRuns) {
            if (run['navigationEndpoint']?['browseEndpoint']?['browseEndpointContextSupportedConfigs'] != null ||
                run['navigationEndpoint']?['browseEndpoint']?['browseId']?.startsWith('UC') == true) {
              artist = run['text'];
              break;
            }
          }
          artist ??= subtitleRuns.firstWhere(
            (run) => run['text'] != ' ‚Ä¢ ',
            orElse: () => {'text': null},
          )['text'];
        }

        String? thumbUrl;
        final thumbnails = renderer['thumbnail']?['musicThumbnailRenderer']?['thumbnail']?['thumbnails'];
        if (thumbnails is List && thumbnails.isNotEmpty) {
          thumbUrl = thumbnails.last['url'];
        }

        final videoId = renderer['overlay']?['musicItemThumbnailOverlayRenderer']?['content']?['musicPlayButtonRenderer']?['playNavigationEndpoint']?['watchEndpoint']?['videoId'];

        if (videoId != null && title != null) {
          results.add(
            YtMusicResult(
              title: title,
              artist: artist,
              thumbUrl: thumbUrl,
              videoId: videoId,
            ),
          );
        }
      }
    }
  }
}

// Funci√≥n para buscar solo canciones con paginaci√≥n
Future<List<YtMusicResult>> searchSongsOnly(String query, {String? continuationToken}) async {
  // Cancela la b√∫squeda anterior si existe
  _searchCancelToken?.cancel();
  _searchCancelToken = CancelToken();

  final data = {
    ...ytServiceContext,
    'query': query,
    'params': getSearchParams('songs', null, false),
  };

  if (continuationToken != null) {
    data['continuation'] = continuationToken;
  }

  try {
    final response = (await sendRequest("search", data, cancelToken: _searchCancelToken)).data;
    final results = <YtMusicResult>[];

    // Si es una b√∫squeda inicial
    if (continuationToken == null) {
      final contents = nav(response, [
        'contents',
        'tabbedSearchResultsRenderer',
        'tabs',
        0,
        'tabRenderer',
        'content',
        'sectionListRenderer',
        'contents',
        0,
        'musicShelfRenderer',
        'contents'
      ]);

      if (contents is List) {
        parseSongs(contents, results);
      }
    } else {
      // Si es una continuaci√≥n, la estructura es diferente
      var contents = nav(response, [
        'onResponseReceivedActions',
        0,
        'appendContinuationItemsAction',
        'continuationItems'
      ]);

      contents ??= nav(response, [
        'continuationContents',
        'musicShelfContinuation',
        'contents'
      ]);

      if (contents is List) {
        final songItems = contents.where((item) => 
          item['musicResponsiveListItemRenderer'] != null
        ).toList();
        if (songItems.isNotEmpty) {
          parseSongs(songItems, results);
        }
      }
    }
    return results;
  } on DioException catch (e) {
    if (CancelToken.isCancel(e)) {
      // print('B√∫squeda cancelada');
      return <YtMusicResult>[];
    }
    // Si es un error 400 (bad request), ign√≥ralo y retorna lista vac√≠a
    if (e.response?.statusCode == 400) {
      // print('Error 400 ignorado porque la b√∫squeda fue cancelada o la petici√≥n ya no es v√°lida');
      return <YtMusicResult>[];
    }
    rethrow;
  }
}

// Funci√≥n para buscar con m√∫ltiples p√°ginas
Future<List<YtMusicResult>> searchSongsWithPagination(String query, {int maxPages = 3}) async {
  final allResults = <YtMusicResult>[];
  String? continuationToken;
  int currentPage = 0;

  while (currentPage < maxPages) {
    final data = {
      ...ytServiceContext,
      'params': getSearchParams('songs', null, false),
    };
    if (continuationToken == null) {
      data['query'] = query;
    } else {
      data['continuation'] = continuationToken;
    }
    final response = (await sendRequest("search", data)).data;
    final results = <YtMusicResult>[];
    String? nextToken;
    if (continuationToken == null) {
      final contents = nav(response, [
        'contents',
        'tabbedSearchResultsRenderer',
        'tabs',
        0,
        'tabRenderer',
        'content',
        'sectionListRenderer',
        'contents',
        0,
        'musicShelfRenderer',
        'contents'
      ]);
      if (contents is List) {
        parseSongs(contents, results);
      }
      final shelfRenderer = nav(response, [
        'contents',
        'tabbedSearchResultsRenderer',
        'tabs',
        0,
        'tabRenderer',
        'content',
        'sectionListRenderer',
        'contents',
        0,
        'musicShelfRenderer'
      ]);
      if (shelfRenderer != null && shelfRenderer['continuations'] != null) {
        nextToken = shelfRenderer['continuations'][0]['nextContinuationData']['continuation'];
      }
    } else {
      var contents = nav(response, [
        'onResponseReceivedActions',
        0,
        'appendContinuationItemsAction',
        'continuationItems'
      ]);
      contents ??= nav(response, [
        'continuationContents',
        'musicShelfContinuation',
        'contents'
      ]);
      if (contents is List) {
        final songItems = contents.where((item) => 
          item['musicResponsiveListItemRenderer'] != null
        ).toList();
        if (songItems.isNotEmpty) {
          parseSongs(songItems, results);
        }
      }
      String? nextTokenTry;
      try {
        nextTokenTry = nav(response, [
          'onResponseReceivedActions',
          0,
          'appendContinuationItemsAction',
          'continuationItems',
          0,
          'continuationItemRenderer',
          'continuationEndpoint',
          'continuationCommand',
          'token'
        ]);
        nextTokenTry ??= nav(response, [
          'continuationContents',
          'musicShelfContinuation',
          'continuations',
          0,
          'nextContinuationData',
          'continuation'
        ]);
        nextToken = nextTokenTry;
      } catch (e) {
        nextToken = null;
      }
    }
    allResults.addAll(results);
    if (results.isEmpty || nextToken == null) {
      break;
    }
    continuationToken = nextToken;
    currentPage++;
  }
  return allResults;
}

// Funci√≥n para buscar con m√°s resultados por p√°gina
Future<List<YtMusicResult>> searchSongsWithMoreResults(String query) async {
  final data = {
    ...ytServiceContext,
    'query': query,
    'params': getSearchParams('songs', null, false),
  };

  final response = (await sendRequest("search", data)).data;
  final results = <YtMusicResult>[];

  // Obtener todos los contenidos de la respuesta
  final contents = nav(response, [
    'contents',
    'tabbedSearchResultsRenderer',
    'tabs',
    0,
    'tabRenderer',
    'content',
    'sectionListRenderer',
    'contents'
  ]);

  if (contents is List) {
    // Procesar todas las secciones que contengan canciones
    for (var section in contents) {
      final shelfRenderer = section['musicShelfRenderer'];
      if (shelfRenderer != null) {
        final sectionContents = shelfRenderer['contents'];
        if (sectionContents is List) {
          parseSongs(sectionContents, results);
        }
      }
    }
  }

  return results;
}

// Funci√≥n para obtener el token de continuaci√≥n
String? getContinuationToken(Map<String, dynamic> response) {
  try {
    final shelfRenderer = nav(response, [
      'contents',
      'tabbedSearchResultsRenderer',
      'tabs',
      0,
      'tabRenderer',
      'content',
      'sectionListRenderer',
      'contents',
      0,
      'musicShelfRenderer'
    ]);

    if (shelfRenderer != null && shelfRenderer['continuations'] != null) {
      return shelfRenderer['continuations'][0]['nextContinuationData']['continuation'];
    }
  } catch (e) {
    // Si no hay token de continuaci√≥n, retornar null
  }
  return null;
}

// Funci√≥n para obtener sugerencias de b√∫squeda de YouTube Music
Future<List<String>> getSearchSuggestion(String queryStr) async {
  try {
    final data = Map<String, dynamic>.from(ytServiceContext);
    data['input'] = queryStr;
    
    final response = await sendRequest("music/get_search_suggestions", data);
    final responseData = response.data;
    
    final suggestions = nav(responseData, [
      'contents', 
      0, 
      'searchSuggestionsSectionRenderer', 
      'contents'
    ]) ?? [];
    
    return suggestions
        .map<String?>((item) {
          return nav(item, [
            'searchSuggestionRenderer',
            'navigationEndpoint',
            'searchEndpoint',
            'query'
          ])?.toString();
        })
        .whereType<String>()
        .toList();
  } catch (e) {
    return [];
  }
}

Future<List<YtMusicResult>> searchVideosWithPagination(String query, {int maxPages = 3}) async {
  final allResults = <YtMusicResult>[];
  String? continuationToken;
  int currentPage = 0;

  while (currentPage < maxPages) {
    List<YtMusicResult> results = [];
    if (continuationToken == null) {
      // Primera b√∫squeda
      final data = {
        ...ytServiceContext,
        'query': query,
        'params': getSearchParams('videos', null, false),
      };
      final response = (await sendRequest("search", data)).data;
      final contents = nav(response, [
        'contents',
        'tabbedSearchResultsRenderer',
        'tabs',
        0,
        'tabRenderer',
        'content',
        'sectionListRenderer',
        'contents',
        0,
        'musicShelfRenderer',
        'contents',
      ]);
      if (contents is List) {
        for (var item in contents) {
          final renderer = item['musicResponsiveListItemRenderer'];
          if (renderer != null) {
            final videoType = nav(renderer, [
              'overlay',
              'musicItemThumbnailOverlayRenderer',
              'content',
              'musicPlayButtonRenderer',
              'playNavigationEndpoint',
              'watchEndpoint',
              'watchEndpointMusicSupportedConfigs',
              'watchEndpointMusicConfig',
              'musicVideoType'
            ]);
            if (videoType == 'MUSIC_VIDEO_TYPE_MV' ||
                videoType == 'MUSIC_VIDEO_TYPE_OMV' ||
                videoType == 'MUSIC_VIDEO_TYPE_UGC') {
              final title = renderer['flexColumns']?[0]
                  ?['musicResponsiveListItemFlexColumnRenderer']?['text']?['runs']?[0]?['text'];
              final subtitleRuns = renderer['flexColumns']?[1]
                  ?['musicResponsiveListItemFlexColumnRenderer']?['text']?['runs'];
              String? artist;
              if (subtitleRuns is List) {
                for (var run in subtitleRuns) {
                  if (run['navigationEndpoint']?['browseEndpoint']?['browseEndpointContextSupportedConfigs'] != null ||
                      run['navigationEndpoint']?['browseEndpoint']?['browseId']?.startsWith('UC') == true) {
                    artist = run['text'];
                    break;
                  }
                }
                artist ??= subtitleRuns.firstWhere(
                  (run) => run['text'] != ' ‚Ä¢ ',
                  orElse: () => {'text': null},
                )['text'];
              }
              String? thumbUrl;
              final thumbnails = renderer['thumbnail']?['musicThumbnailRenderer']?['thumbnail']?['thumbnails'];
              if (thumbnails is List && thumbnails.isNotEmpty) {
                thumbUrl = thumbnails.last['url'];
              }
              final videoId = renderer['overlay']?['musicItemThumbnailOverlayRenderer']?['content']?['musicPlayButtonRenderer']?['playNavigationEndpoint']?['watchEndpoint']?['videoId'];
              if (videoId != null && title != null) {
                results.add(
                  YtMusicResult(
                    title: title,
                    artist: artist,
                    thumbUrl: thumbUrl,
                    videoId: videoId,
                  ),
                );
              }
            }
          }
        }
      }
      // Obtener el token de continuaci√≥n para la siguiente p√°gina
      final shelfRenderer = nav(response, [
        'contents',
        'tabbedSearchResultsRenderer',
        'tabs',
        0,
        'tabRenderer',
        'content',
        'sectionListRenderer',
        'contents',
        0,
        'musicShelfRenderer',
      ]);
      if (shelfRenderer != null && shelfRenderer['continuations'] != null) {
        continuationToken = shelfRenderer['continuations'][0]['nextContinuationData']['continuation'];
      } else {
        continuationToken = null;
      }
    } else {
      // Continuaciones
      final data = {
        ...ytServiceContext,
        'continuation': continuationToken,
      };
      final response = (await sendRequest("search", data)).data;
      // Intenta ambas rutas, igual que en canciones
      var contents = nav(response, [
        'onResponseReceivedActions',
        0,
        'appendContinuationItemsAction',
        'continuationItems',
      ]);
      contents ??= nav(response, [
        'continuationContents',
        'musicShelfContinuation',
        'contents',
      ]);
      if (contents is List) {
        final videoItems = contents.where((item) => item['musicResponsiveListItemRenderer'] != null).toList();
        for (var item in videoItems) {
          final renderer = item['musicResponsiveListItemRenderer'];
          if (renderer != null) {
            final videoType = nav(renderer, [
              'overlay',
              'musicItemThumbnailOverlayRenderer',
              'content',
              'musicPlayButtonRenderer',
              'playNavigationEndpoint',
              'watchEndpoint',
              'watchEndpointMusicSupportedConfigs',
              'watchEndpointMusicConfig',
              'musicVideoType'
            ]);
            if (videoType == 'MUSIC_VIDEO_TYPE_MV' ||
                videoType == 'MUSIC_VIDEO_TYPE_OMV' ||
                videoType == 'MUSIC_VIDEO_TYPE_UGC') {
              final title = renderer['flexColumns']?[0]
                  ?['musicResponsiveListItemFlexColumnRenderer']?['text']?['runs']?[0]?['text'];
              final subtitleRuns = renderer['flexColumns']?[1]
                  ?['musicResponsiveListItemFlexColumnRenderer']?['text']?['runs'];
              String? artist;
              if (subtitleRuns is List) {
                for (var run in subtitleRuns) {
                  if (run['navigationEndpoint']?['browseEndpoint']?['browseEndpointContextSupportedConfigs'] != null ||
                      run['navigationEndpoint']?['browseEndpoint']?['browseId']?.startsWith('UC') == true) {
                    artist = run['text'];
                    break;
                  }
                }
                artist ??= subtitleRuns.firstWhere(
                  (run) => run['text'] != ' ‚Ä¢ ',
                  orElse: () => {'text': null},
                )['text'];
              }
              String? thumbUrl;
              final thumbnails = renderer['thumbnail']?['musicThumbnailRenderer']?['thumbnail']?['thumbnails'];
              if (thumbnails is List && thumbnails.isNotEmpty) {
                thumbUrl = thumbnails.last['url'];
              }
              final videoId = renderer['overlay']?['musicItemThumbnailOverlayRenderer']?['content']?['musicPlayButtonRenderer']?['playNavigationEndpoint']?['watchEndpoint']?['videoId'];
              if (videoId != null && title != null) {
                results.add(
                  YtMusicResult(
                    title: title,
                    artist: artist,
                    thumbUrl: thumbUrl,
                    videoId: videoId,
                  ),
                );
              }
            }
          }
        }
      }
      // Obtener el siguiente token de continuaci√≥n
      String? nextToken;
      try {
        nextToken = nav(response, [
          'onResponseReceivedActions',
          0,
          'appendContinuationItemsAction',
          'continuationItems',
          0,
          'continuationItemRenderer',
          'continuationEndpoint',
          'continuationCommand',
          'token',
        ]);
        // Si no hay, intenta la ruta alternativa
        nextToken ??= nav(response, [
          'continuationContents',
          'musicShelfContinuation',
          'continuations',
          0,
          'nextContinuationData',
          'continuation'
        ]);
        continuationToken = nextToken;
      } catch (e) {
        continuationToken = null;
      }
    }
    if (results.isEmpty) break;
    allResults.addAll(results);
    if (continuationToken == null) break;
    currentPage++;
  }
  return allResults;
}

Future<List<Map<String, String>>> searchAlbumsOnly(String query) async {
  final data = {
    ...ytServiceContext,
    'query': query,
    // Puedes probar con o sin el filtro 'albums'
    // 'params': getSearchParams('albums', null, false),
  };
  final response = (await sendRequest("search", data)).data;
  final results = <Map<String, String>>[];

  final sections = nav(response, [
    'contents',
    'tabbedSearchResultsRenderer',
    'tabs',
    0,
    'tabRenderer',
    'content',
    'sectionListRenderer',
    'contents'
  ]);
  if (sections is List) {
    for (var section in sections) {
      // Busca cualquier shelf
      final shelf = section['musicShelfRenderer'];
      if (shelf != null && shelf['contents'] is List) {
        for (var item in shelf['contents']) {
          final renderer = item['musicResponsiveListItemRenderer'];
          if (renderer != null) {
            // Extraer browseId de cualquier men√∫
            String? browseId;
            final menuItems = renderer['menu']?['menuRenderer']?['items'];
            if (menuItems is List) {
              for (var menuItem in menuItems) {
                final endpoint = menuItem['menuNavigationItemRenderer']?['navigationEndpoint']?['browseEndpoint'];
                if (endpoint != null && endpoint['browseId'] != null && endpoint['browseId'].toString().startsWith('MPRE')) {
                  browseId = endpoint['browseId'];
                  break;
                }
              }
            }
            // Si no hay browseId, ignora el item
            if (browseId == null) continue;

            final title = renderer['flexColumns']?[0]?['musicResponsiveListItemFlexColumnRenderer']?['text']?['runs']?[0]?['text'];
            final subtitleRuns = renderer['flexColumns']?[1]?['musicResponsiveListItemFlexColumnRenderer']?['text']?['runs'];
            String? artist;
            if (subtitleRuns is List) {
              artist = subtitleRuns.firstWhere(
                (run) => run['text'] != ' ‚Ä¢ ',
                orElse: () => {'text': null},
              )['text'];
            }
            String? thumbUrl;
            final thumbnails = renderer['thumbnail']?['musicThumbnailRenderer']?['thumbnail']?['thumbnails'];
            if (thumbnails is List && thumbnails.isNotEmpty) {
              thumbUrl = thumbnails.last['url'];
            }
            results.add({
              'title': title,
              'artist': artist ?? '',
              'thumbUrl': thumbUrl ?? '',
              'browseId': browseId,
            });
          }
        }
      }
    }
  }
  return results;
}

Future<List<YtMusicResult>> getAlbumSongs(String browseId) async {
  final data = {
    ...ytServiceContext,
    'browseId': browseId,
  };
  final response = (await sendRequest("browse", data)).data;

  // Intenta ambas rutas posibles
  var shelf = nav(response, [
    'contents',
    'twoColumnBrowseResultsRenderer',
    'secondaryContents',
    'sectionListRenderer',
    'contents',
    0,
    'musicShelfRenderer',
    'contents',
  ]);
  shelf ??= nav(response, [
    'contents',
    'singleColumnBrowseResultsRenderer',
    'tabs',
    0,
    'tabRenderer',
    'content',
    'sectionListRenderer',
    'contents',
    0,
    'musicShelfRenderer',
    'contents',
  ]);

  final results = <YtMusicResult>[];
  if (shelf is List) {
    for (var item in shelf) {
      final renderer = item['musicResponsiveListItemRenderer'];
      if (renderer != null) {
        final title = renderer['flexColumns']?[0]?['musicResponsiveListItemFlexColumnRenderer']?['text']?['runs']?[0]?['text'];
        final subtitleRuns = renderer['flexColumns']?[1]?['musicResponsiveListItemFlexColumnRenderer']?['text']?['runs'];
        String? artist;
        if (subtitleRuns is List) {
          artist = subtitleRuns
              .where((run) => run['text'] != ' ‚Ä¢ ')
              .map((run) => run['text'])
              .join(', ');
        }
        String? thumbUrl;
        final thumbnails = renderer['thumbnail']?['musicThumbnailRenderer']?['thumbnail']?['thumbnails'];
        if (thumbnails is List && thumbnails.isNotEmpty) {
          thumbUrl = thumbnails.last['url'];
        }
        final videoId = renderer['overlay']?['musicItemThumbnailOverlayRenderer']?['content']?['musicPlayButtonRenderer']?['playNavigationEndpoint']?['watchEndpoint']?['videoId'];
        if (videoId != null && title != null) {
          results.add(
            YtMusicResult(
              title: title,
              artist: artist,
              thumbUrl: thumbUrl,
              videoId: videoId,
            ),
          );
        }
      }
    }
  }
  return results;
}

// Funci√≥n mejorada para buscar listas de reproducci√≥n con paginaci√≥n
Future<List<Map<String, String>>> searchPlaylistsWithPagination(String query, {int maxPages = 3}) async {
  final allResults = <Map<String, String>>[];
  String? continuationToken;
  int currentPage = 0;

  while (currentPage < maxPages) {
    final data = {
      ...ytServiceContext,
      'query': query,
      'params': getSearchParams('playlists', null, false),
    };

    if (continuationToken != null) {
      data['continuation'] = continuationToken;
    }

    try {
      final response = (await sendRequest("search", data)).data;
      final results = <Map<String, String>>[];
      String? nextToken;

      if (continuationToken == null) {
        // Primera b√∫squeda
        final sections = nav(response, [
          'contents',
          'tabbedSearchResultsRenderer',
          'tabs',
          0,
          'tabRenderer',
          'content',
          'sectionListRenderer',
          'contents'
        ]);

        if (sections is List) {
          for (var section in sections) {
            final shelf = section['musicShelfRenderer'];
            if (shelf != null && shelf['contents'] is List) {
              for (var item in shelf['contents']) {
                final renderer = item['musicResponsiveListItemRenderer'];
                if (renderer != null) {
                  final playlistData = _parsePlaylistItem(renderer);
                  if (playlistData != null) {
                    results.add(playlistData);
                  }
                }
              }
            }
          }
        }

        // Obtener token de continuaci√≥n
        final shelfRenderer = nav(response, [
          'contents',
          'tabbedSearchResultsRenderer',
          'tabs',
          0,
          'tabRenderer',
          'content',
          'sectionListRenderer',
          'contents',
          0,
          'musicShelfRenderer'
        ]);

        if (shelfRenderer != null && shelfRenderer['continuations'] != null) {
          nextToken = shelfRenderer['continuations'][0]['nextContinuationData']['continuation'];
        }
      } else {
        // Continuaciones
        var contents = nav(response, [
          'onResponseReceivedActions',
          0,
          'appendContinuationItemsAction',
          'continuationItems'
        ]);

        contents ??= nav(response, [
          'continuationContents',
          'musicShelfContinuation',
          'contents'
        ]);

        if (contents is List) {
          final playlistItems = contents.where((item) => 
            item['musicResponsiveListItemRenderer'] != null
          ).toList();

          for (var item in playlistItems) {
            final renderer = item['musicResponsiveListItemRenderer'];
            if (renderer != null) {
              final playlistData = _parsePlaylistItem(renderer);
              if (playlistData != null) {
                results.add(playlistData);
              }
            }
          }
        }

        // Obtener siguiente token
        try {
          nextToken = nav(response, [
            'onResponseReceivedActions',
            0,
            'appendContinuationItemsAction',
            'continuationItems',
            0,
            'continuationItemRenderer',
            'continuationEndpoint',
            'continuationCommand',
            'token'
          ]);

          nextToken ??= nav(response, [
            'continuationContents',
            'musicShelfContinuation',
            'continuations',
            0,
            'nextContinuationData',
            'continuation'
          ]);
        } catch (e) {
          nextToken = null;
        }
      }

      allResults.addAll(results);
      
      if (results.isEmpty || nextToken == null) {
        break;
      }
      
      continuationToken = nextToken;
      currentPage++;
    } catch (e) {
      // ('Error en b√∫squeda de playlists: $e');
      break;
    }
  }

  return allResults;
}

// Funci√≥n simple para compatibilidad con el c√≥digo existente
Future<List<Map<String, String>>> searchPlaylistsOnly(String query) async {
  return await searchPlaylistsWithPagination(query, maxPages: 1);
}

// Funci√≥n auxiliar para parsear items de playlist individuales
Map<String, String>? _parsePlaylistItem(Map<String, dynamic> renderer) {
  // Extraer browseId de los men√∫s (m√°s robusto que la implementaci√≥n anterior)
  String? browseId;
  final menuItems = renderer['menu']?['menuRenderer']?['items'];
  
  if (menuItems is List) {
    for (var menuItem in menuItems) {
      final endpoint = menuItem['menuNavigationItemRenderer']?['navigationEndpoint']?['browseEndpoint'];
      if (endpoint != null && endpoint['browseId'] != null) {
        final id = endpoint['browseId'].toString();
        // Aceptar diferentes tipos de IDs de playlist
        if (id.startsWith('VL') || id.startsWith('PL') || id.startsWith('OL')) {
          browseId = id;
          break;
        }
      }
    }
  }

  // Si no hay browseId en el men√∫, intentar extraerlo de otros lugares
  if (browseId == null) {
    // Intentar desde el overlay
    browseId = nav(renderer, [
      'overlay',
      'musicItemThumbnailOverlayRenderer',
      'content',
      'musicPlayButtonRenderer',
      'playNavigationEndpoint',
      'watchPlaylistEndpoint',
      'playlistId'
    ])?.toString();

    // O desde navigationEndpoint
    browseId ??= nav(renderer, [
      'flexColumns',
      0,
      'musicResponsiveListItemFlexColumnRenderer',
      'text',
      'runs',
      0,
      'navigationEndpoint',
      'browseEndpoint',
      'browseId'
    ])?.toString();
  }

  if (browseId == null) return null;

  // Extraer t√≠tulo
  final title = renderer['flexColumns']?[0]?['musicResponsiveListItemFlexColumnRenderer']?['text']?['runs']?[0]?['text'];
  if (title == null) return null;

  // Extraer n√∫mero de elementos
  final subtitleRuns = renderer['flexColumns']?[1]?['musicResponsiveListItemFlexColumnRenderer']?['text']?['runs'];
  String? itemCount;
  
  if (subtitleRuns is List) {
    // Buscar el n√∫mero de elementos (generalmente el √∫ltimo run num√©rico)
    for (var i = subtitleRuns.length - 1; i >= 0; i--) {
      final text = subtitleRuns[i]['text'];
      if (text != null && RegExp(r'\d+').hasMatch(text)) {
        itemCount = text;
        break;
      }
    }
  }

  // Extraer thumbnail
  String? thumbUrl;
  final thumbnails = renderer['thumbnail']?['musicThumbnailRenderer']?['thumbnail']?['thumbnails'];
  if (thumbnails is List && thumbnails.isNotEmpty) {
    thumbUrl = thumbnails.last['url'];
  }

  return {
    'title': title,
    'browseId': browseId,
    'thumbUrl': thumbUrl ?? '',
    'itemCount': itemCount ?? '0',
  };
}

// Funci√≥n principal mejorada para obtener canciones de una lista de reproducci√≥n
Future<List<YtMusicResult>> getPlaylistSongs(String playlistId, {int? limit}) async {
  // Convertir el ID de playlist al formato correcto
  String browseId = playlistId.startsWith("VL") ? playlistId : "VL$playlistId";
  
  final data = {
    ...ytServiceContext,
    'browseId': browseId,
  };

  try {
    // print('üéµ Iniciando obtenci√≥n de canciones para playlist: $playlistId');
    final response = (await sendRequest("browse", data)).data;
    final results = <YtMusicResult>[];

    // Buscar las canciones en diferentes ubicaciones posibles
    var contents = _findPlaylistContents(response);
    // print('üéµ Contenido inicial encontrado: ${contents?.length ?? 0} items');
    
    if (contents is List) {
      // Parsear las canciones iniciales
      final initialSongs = _parsePlaylistItems(contents);
      results.addAll(initialSongs);
      // print('üéµ Canciones iniciales parseadas: ${initialSongs.length}');

      // Si no hay l√≠mite o necesitamos m√°s canciones, obtener continuaciones
      if (limit == null || results.length < limit) {
        // print('üéµ Iniciando continuaciones...');
        final continuationSongs = await _getPlaylistContinuationsImproved(
          response, 
          data, 
          limit ?? 999999 // L√≠mite muy alto si no se especifica
        );
        // print('üéµ Canciones de continuaciones obtenidas: ${continuationSongs.length}');
        results.addAll(continuationSongs);
      }
    }

    // print('üéµ Total de canciones obtenidas: ${results.length}');
    // Aplicar l√≠mite solo si se especifica
    return limit != null ? results.take(limit).toList() : results;
  } catch (e) {
    // print('‚ùå Error obteniendo canciones de playlist: $e');
    return [];
  }
}

// Funci√≥n mejorada para encontrar el contenido de la playlist (inspirada en Harmony)
List<dynamic>? _findPlaylistContents(Map<String, dynamic> response) {
  // Intentar m√∫ltiples rutas para encontrar las canciones
  var contents = nav(response, [
    'contents',
    'twoColumnBrowseResultsRenderer',
    'secondaryContents',
    'sectionListRenderer',
    'contents',
    0,
    'musicPlaylistShelfRenderer',
    'contents'
  ]);

  contents ??= nav(response, [
    'contents',
    'singleColumnBrowseResultsRenderer',
    'tabs',
    0,
    'tabRenderer',
    'content',
    'sectionListRenderer',
    'contents',
    0,
    'musicPlaylistShelfRenderer',
    'contents'
  ]);

  // Agregar m√°s rutas de b√∫squeda
  contents ??= nav(response, [
    'contents',
    'twoColumnBrowseResultsRenderer',
    'secondaryContents',
    'sectionListRenderer',
    'contents',
    0,
    'musicShelfRenderer',
    'contents'
  ]);

  contents ??= nav(response, [
    'contents',
    'singleColumnBrowseResultsRenderer',
    'tabs',
    0,
    'tabRenderer',
    'content',
    'sectionListRenderer',
    'contents',
    0,
    'musicShelfRenderer',
    'contents'
  ]);

  // Buscar en la estructura de playlist espec√≠fica
  contents ??= nav(response, [
    'contents',
    'twoColumnBrowseResultsRenderer',
    'tabs',
    0,
    'tabRenderer',
    'content',
    'sectionListRenderer',
    'contents',
    0,
    'musicPlaylistShelfRenderer',
    'contents'
  ]);

  // Buscar en estructura de single column con tabs
  contents ??= nav(response, [
    'contents',
    'singleColumnBrowseResultsRenderer',
    'tabs',
    0,
    'tabRenderer',
    'content',
    'sectionListRenderer',
    'contents',
    0,
    'musicShelfRenderer',
    'contents'
  ]);

  // Buscar en estructura de two column con tabs
  contents ??= nav(response, [
    'contents',
    'twoColumnBrowseResultsRenderer',
    'tabs',
    0,
    'tabRenderer',
    'content',
    'sectionListRenderer',
    'contents',
    0,
    'musicShelfRenderer',
    'contents'
  ]);

  return contents;
}

// Funci√≥n para parsear los items de la playlist
List<YtMusicResult> _parsePlaylistItems(List<dynamic> contents) {
  final results = <YtMusicResult>[];

  for (var item in contents) {
    final renderer = item['musicResponsiveListItemRenderer'];
    if (renderer != null) {
      final song = _parsePlaylistSong(renderer);
      if (song != null) {
        results.add(song);
      }
    }
  }

  return results;
}

// Funci√≥n para parsear una canci√≥n individual de la playlist
YtMusicResult? _parsePlaylistSong(Map<String, dynamic> renderer) {
  // Obtener videoId de diferentes ubicaciones
  String? videoId = nav(renderer, ['playlistItemData', 'videoId']);
  
  // Si no est√° en playlistItemData, buscar en el men√∫
  if (videoId == null && renderer.containsKey('menu')) {
    final menuItems = nav(renderer, ['menu', 'menuRenderer', 'items']);
    if (menuItems is List) {
      for (var menuItem in menuItems) {
        if (menuItem.containsKey('menuServiceItemRenderer')) {
          final menuService = nav(menuItem, [
            'menuServiceItemRenderer',
            'serviceEndpoint',
            'playlistEditEndpoint'
          ]);
          if (menuService != null) {
            videoId = nav(menuService, ['actions', 0, 'removedVideoId']);
            if (videoId != null) break;
          }
        }
      }
    }
  }

  // Si a√∫n no tenemos videoId, buscar en el bot√≥n de play
  if (videoId == null) {
    final playButton = nav(renderer, [
      'overlay',
      'musicItemThumbnailOverlayRenderer',
      'content',
      'musicPlayButtonRenderer',
      'playNavigationEndpoint',
      'watchEndpoint'
    ]);
    if (playButton != null) {
      videoId = playButton['videoId'];
    }
  }

  if (videoId == null) return null;

  // Obtener t√≠tulo
  final title = nav(renderer, [
    'flexColumns',
    0,
    'musicResponsiveListItemFlexColumnRenderer',
    'text',
    'runs',
    0,
    'text'
  ]);

  if (title == null || title == 'Song deleted') return null;

  // Obtener artista
  String? artist;
  final subtitleRuns = nav(renderer, [
    'flexColumns',
    1,
    'musicResponsiveListItemFlexColumnRenderer',
    'text',
    'runs'
  ]);

  if (subtitleRuns is List) {
    // Buscar el primer run que no sea " ‚Ä¢ " y que tenga navigationEndpoint
    for (var run in subtitleRuns) {
      if (run['text'] != ' ‚Ä¢ ' && 
          run['text'] != null && 
          run['navigationEndpoint'] != null) {
        artist = run['text'];
        break;
      }
    }
    
    // Si no encontramos artista con navigationEndpoint, tomar el primero que no sea " ‚Ä¢ "
    artist ??= subtitleRuns.firstWhere(
      (run) => run['text'] != ' ‚Ä¢ ' && run['text'] != null,
      orElse: () => {'text': null},
    )['text'];
  }

  // Obtener duraci√≥n (comentado ya que YtMusicResult no tiene este campo)
  // String? duration;
  // final fixedColumns = nav(renderer, ['fixedColumns']);
  // if (fixedColumns != null && fixedColumns is List && fixedColumns.isNotEmpty) {
  //   final durationText = nav(fixedColumns[0], ['text', 'simpleText']) ??
  //       nav(fixedColumns[0], ['text', 'runs', 0, 'text']);
  //   duration = durationText;
  // }

  // Obtener thumbnail
  String? thumbUrl;
  final thumbnails = nav(renderer, [
    'thumbnail',
    'musicThumbnailRenderer',
    'thumbnail',
    'thumbnails'
  ]);
  if (thumbnails is List && thumbnails.isNotEmpty) {
    thumbUrl = thumbnails.last['url'];
  }

  return YtMusicResult(
    title: title,
    artist: artist,
    thumbUrl: thumbUrl,
    videoId: videoId,
  );
}

// Funci√≥n mejorada para obtener continuaciones (inspirada en Harmony Music)
Future<List<YtMusicResult>> _getPlaylistContinuationsImproved(
  Map<String, dynamic> response, 
  Map<String, dynamic> data, 
  int limit
) async {
  final results = <YtMusicResult>[];
  
  // Buscar token de continuaci√≥n en m√∫ltiples ubicaciones
  String? continuationToken = _getPlaylistContinuationTokenImproved(response);
  // print('üîÑ Token de continuaci√≥n inicial: ${continuationToken != null ? "Encontrado" : "No encontrado"}');
  
  int maxAttempts = 50; // L√≠mite de intentos para obtener todas las canciones
  int attempts = 0;
  
  while (continuationToken != null && results.length < limit && attempts < maxAttempts) {
    try {
      // print('üîÑ Intento ${attempts + 1}: Obteniendo continuaciones...');
      final continuationData = {
        ...data,
        'continuation': continuationToken,
      };
      
      final continuationResponse = (await sendRequest("browse", continuationData)).data;
      
      // Buscar items de continuaci√≥n en m√∫ltiples ubicaciones
      var continuationItems = nav(continuationResponse, [
        'continuationContents',
        'musicPlaylistShelfContinuation',
        'contents'
      ]);
      
      continuationItems ??= nav(continuationResponse, [
        'onResponseReceivedActions',
        0,
        'appendContinuationItemsAction',
        'continuationItems'
      ]);

      continuationItems ??= nav(continuationResponse, [
        'continuationContents',
        'musicShelfContinuation',
        'contents'
      ]);

      // Buscar en estructura de tabs
      continuationItems ??= nav(continuationResponse, [
        'contents',
        'twoColumnBrowseResultsRenderer',
        'tabs',
        0,
        'tabRenderer',
        'content',
        'sectionListRenderer',
        'contents',
        0,
        'musicPlaylistShelfRenderer',
        'contents'
      ]);

      continuationItems ??= nav(continuationResponse, [
        'contents',
        'singleColumnBrowseResultsRenderer',
        'tabs',
        0,
        'tabRenderer',
        'content',
        'sectionListRenderer',
        'contents',
        0,
        'musicPlaylistShelfRenderer',
        'contents'
      ]);

      if (continuationItems != null && continuationItems is List) {
        final songs = _parsePlaylistItems(continuationItems);
        results.addAll(songs);
        // print('üîÑ Canciones obtenidas en intento ${attempts + 1}: ${songs.length} (Total: ${results.length})');
        
        // Obtener siguiente token
        continuationToken = _getPlaylistContinuationTokenImproved(continuationResponse);
        // print('üîÑ Siguiente token: ${continuationToken != null ? "Encontrado" : "No encontrado"}');
        
        // Si no hay m√°s token, verificar si hay m√°s contenido
        if (continuationToken == null) {
          // print('üîÑ No hay m√°s token, verificando si hay m√°s contenido...');
          // Verificar si hay m√°s items en la respuesta actual
          var moreItems = nav(continuationResponse, [
            'contents',
            'twoColumnBrowseResultsRenderer',
            'secondaryContents',
            'sectionListRenderer',
            'contents',
            0,
            'musicPlaylistShelfRenderer',
            'contents'
          ]);
          if (moreItems is List && moreItems.isNotEmpty) {
            // print('üîÑ Encontrados ${moreItems.length} items adicionales en la respuesta actual');
            final additionalSongs = _parsePlaylistItems(moreItems);
            results.addAll(additionalSongs);
            // print('üîÑ Canciones adicionales agregadas: ${additionalSongs.length} (Total: ${results.length})');
          }
        }
      } else {
        // print('üîÑ No se encontraron items de continuaci√≥n en intento ${attempts + 1}');
        break;
      }
      
      attempts++;
    } catch (e) {
      // print('Error en continuaci√≥n de playlist (intento $attempts): $e');
      break;
    }
  }
  
  // print('üîÑ Total de continuaciones completadas: $attempts intentos, ${results.length} canciones obtenidas');
  return results;
}

// Funci√≥n corregida para obtener el token de continuaci√≥n
String? _getPlaylistContinuationTokenImproved(Map<String, dynamic> response) {
  // print('üîç Buscando token de continuaci√≥n...');
  
  // PRIMERO: Buscar en el √∫ltimo elemento de contents (como hace Harmony)
  var contents = _findPlaylistContents(response);
  if (contents is List && contents.isNotEmpty) {
    final lastItem = contents.last;
    if (lastItem is Map && lastItem.containsKey('continuationItemRenderer')) {
      final token = nav(lastItem, [
        'continuationItemRenderer',
        'continuationEndpoint',
        'continuationCommand',
        'token'
      ]);
      if (token != null) {
        // print('üîç Token encontrado en √∫ltimo elemento de contents: Encontrado');
        return token;
      }
    }
  }
  // print('üîç Token en √∫ltimo elemento de contents: No encontrado');

  // SEGUNDO: Buscar en las ubicaciones tradicionales (como respaldo)
  var token = nav(response, [
    'contents',
    'twoColumnBrowseResultsRenderer',
    'secondaryContents',
    'sectionListRenderer',
    'contents',
    0,
    'musicPlaylistShelfRenderer',
    'continuations',
    0,
    'nextContinuationData',
    'continuation'
  ]);
  // print('üîç Token en twoColumnBrowseResultsRenderer->secondaryContents: ${token != null ? "Encontrado" : "No encontrado"}');

  token ??= nav(response, [
    'contents',
    'singleColumnBrowseResultsRenderer',
    'tabs',
    0,
    'tabRenderer',
    'content',
    'sectionListRenderer',
    'contents',
    0,
    'musicPlaylistShelfRenderer',
    'continuations',
    0,
    'nextContinuationData',
    'continuation'
  ]);
  // print('üîç Token en singleColumnBrowseResultsRenderer->tabs: ${token != null ? "Encontrado" : "No encontrado"}');

  token ??= nav(response, [
    'continuationContents',
    'musicPlaylistShelfContinuation',
    'continuations',
    0,
    'nextContinuationData',
    'continuation'
  ]);
  // print('üîç Token en continuationContents->musicPlaylistShelfContinuation: ${token != null ? "Encontrado" : "No encontrado"}');

  // Buscar en estructura de tabs
  token ??= nav(response, [
    'contents',
    'twoColumnBrowseResultsRenderer',
    'tabs',
    0,
    'tabRenderer',
    'content',
    'sectionListRenderer',
    'contents',
    0,
    'musicPlaylistShelfRenderer',
    'continuations',
    0,
    'nextContinuationData',
    'continuation'
  ]);
  // print('üîç Token en twoColumnBrowseResultsRenderer->tabs: ${token != null ? "Encontrado" : "No encontrado"}');

  token ??= nav(response, [
    'contents',
    'singleColumnBrowseResultsRenderer',
    'tabs',
    0,
    'tabRenderer',
    'content',
    'sectionListRenderer',
    'contents',
    0,
    'musicShelfRenderer',
    'continuations',
    0,
    'nextContinuationData',
    'continuation'
  ]);
  // print('üîç Token en singleColumnBrowseResultsRenderer->tabs->musicShelfRenderer: ${token != null ? "Encontrado" : "No encontrado"}');

  // Buscar en onResponseReceivedActions
  token ??= nav(response, [
    'onResponseReceivedActions',
    0,
    'appendContinuationItemsAction',
    'continuationItems',
    0,
    'continuationItemRenderer',
    'continuationEndpoint',
    'continuationCommand',
    'token'
  ]);
  // print('üîç Token en onResponseReceivedActions: ${token != null ? "Encontrado" : "No encontrado"}');

  // Buscar en continuationContents
  token ??= nav(response, [
    'continuationContents',
    'musicShelfContinuation',
    'continuations',
    0,
    'nextContinuationData',
    'continuation'
  ]);
  // print('üîç Token en continuationContents->musicShelfContinuation: ${token != null ? "Encontrado" : "No encontrado"}');

  // Buscar en continuationContents->musicPlaylistShelfContinuation
  token ??= nav(response, [
    'continuationContents',
    'musicPlaylistShelfContinuation',
    'continuations',
    0,
    'nextContinuationData',
    'continuation'
  ]);
  // print('üîç Token en continuationContents->musicPlaylistShelfContinuation: ${token != null ? "Encontrado" : "No encontrado"}');

  // Buscar en el √∫ltimo elemento de continuationItems (para respuestas de continuaci√≥n)
  var continuationItems = nav(response, [
    'onResponseReceivedActions',
    0,
    'appendContinuationItemsAction',
    'continuationItems'
  ]);
  if (continuationItems is List && continuationItems.isNotEmpty) {
    final lastItem = continuationItems.last;
    if (lastItem is Map && lastItem.containsKey('continuationItemRenderer')) {
      final continuationToken = nav(lastItem, [
        'continuationItemRenderer',
        'continuationEndpoint',
        'continuationCommand',
        'token'
      ]);
      if (continuationToken != null) {
        token = continuationToken;
        // print('üîç Token encontrado en √∫ltimo elemento de continuationItems: Encontrado');
      }
    }
  }
  // print('üîç Token en √∫ltimo elemento de continuationItems: ${token != null ? "Encontrado" : "No encontrado"}');

  // print('üîç Token final: ${token != null ? "Encontrado" : "No encontrado"}');
  return token;
}

// Funci√≥n para obtener informaci√≥n de la playlist (t√≠tulo, autor, etc.)
Future<Map<String, dynamic>?> getPlaylistInfo(String playlistId) async {
  String browseId = playlistId.startsWith("VL") ? playlistId : "VL$playlistId";
  
  final data = {
    ...ytServiceContext,
    'browseId': browseId,
  };

  try {
    final response = (await sendRequest("browse", data)).data;
    
    // Buscar header en diferentes ubicaciones
    var header = nav(response, ['header', 'musicDetailHeaderRenderer']);
    
    header ??= nav(response, [
      'contents',
      'twoColumnBrowseResultsRenderer',
      'tabs',
      0,
      'tabRenderer',
      'content',
      'sectionListRenderer',
      'contents',
      0,
      'musicResponsiveHeaderRenderer'
    ]);

    if (header == null) return null;

    // Extraer informaci√≥n del header
    final title = nav(header, ['title', 'runs', 0, 'text']);
    final description = nav(header, [
      'description',
      'musicDescriptionShelfRenderer',
      'description',
      'runs',
      0,
      'text'
    ]);

    // Extraer n√∫mero de canciones
    String? songCount;
    final secondSubtitleRuns = nav(header, ['secondSubtitle', 'runs']);
    if (secondSubtitleRuns is List && secondSubtitleRuns.isNotEmpty) {
      final countText = nav(secondSubtitleRuns[0], ['text']);
      if (countText != null) {
        final match = RegExp(r'(\d+)').firstMatch(countText);
        songCount = match?.group(1);
      }
    }

    // Extraer thumbnail
    String? thumbUrl;
    final thumbnails = nav(header, [
      'thumbnail',
      'musicThumbnailRenderer',
      'thumbnail',
      'thumbnails'
    ]);
    if (thumbnails is List && thumbnails.isNotEmpty) {
      thumbUrl = thumbnails.last['url'];
    }

    return {
      'title': title,
      'description': description,
      'songCount': songCount,
      'thumbUrl': thumbUrl,
    };
  } catch (e) {
    // print('Error obteniendo informaci√≥n de playlist: $e');
    return null;
  }
}

// Funci√≥n corregida para buscar artistas espec√≠ficamente
Future<List<Map<String, dynamic>>> searchArtists(String query, {int limit = 20}) async {
  // print('üöÄ Iniciando b√∫squeda de artistas para: $query');
  
  final data = {
    ...ytServiceContext,
    'query': query,
    'params': getSearchParams('artists', null, false),
  };

  try {
    // print('üì° Enviando petici√≥n a YouTube Music API...');
    final response = (await sendRequest("search", data)).data;
    // print('üì° Respuesta recibida, status: ${response != null ? 'OK' : 'NULL'}');
    final results = <Map<String, dynamic>>[];

    // print('üîç Buscando artistas para: $query');
    // print('üîç Par√°metros de b√∫squeda: ${data['params']}');

    // Buscar directamente en la estructura de resultados
    final contents = nav(response, [
      'contents',
      'tabbedSearchResultsRenderer',
      'tabs',
      0,
      'tabRenderer',
      'content',
      'sectionListRenderer',
      'contents'
    ]);

    // print('üîç Contenidos encontrados: ${contents?.length ?? 0}');

    if (contents is List) {
      for (var section in contents) {
        final shelf = section['musicShelfRenderer'];
        if (shelf != null && shelf['contents'] is List) {
          // print('üîç Procesando shelf con ${shelf['contents'].length} items');
          for (var item in shelf['contents']) {
            final artist = _parseArtistItem(item);
            if (artist != null) {
              // Verificar si ya existe un artista con el mismo nombre y browseId
              final existingArtist = results.firstWhere(
                (existing) => existing['name'] == artist['name'] && existing['browseId'] == artist['browseId'],
                orElse: () => {},
              );
              
              // Solo agregar si no existe ya
              if (existingArtist.isEmpty) {
                // print('üéµ Artista encontrado: ${artist['name']} - BrowseId: ${artist['browseId']} - Thumb: ${artist['thumbUrl'] != null ? 'S√≠' : 'No'}');
                results.add(artist);
                if (results.length >= limit) break;
              } else {
                // print('üîÑ Artista duplicado ignorado: ${artist['name']} - BrowseId: ${artist['browseId']}');
              }
            }
          }
        }
        if (results.length >= limit) break;
      }
    }

    // print('üîç Total artistas encontrados: ${results.length}');
    return results.take(limit).toList();
  } on DioException catch (_) {
    // print('‚ùå Error de red buscando artistas: ${e.message}');
    // print('‚ùå Tipo de error: ${e.type}');
    return [];
  } catch (e) {
    // print('‚ùå Error general buscando artistas: $e');
    return [];
  }
}

// Funci√≥n auxiliar mejorada para parsear un item de artista
Map<String, dynamic>? _parseArtistItem(Map<String, dynamic> item) {
  final renderer = item['musicResponsiveListItemRenderer'];
  if (renderer == null) {
    // ('‚ùå No se encontr√≥ musicResponsiveListItemRenderer');
    return null;
  }

  // Extraer nombre del artista
  final title = nav(renderer, [
    'flexColumns',
    0,
    'musicResponsiveListItemFlexColumnRenderer',
    'text',
    'runs',
    0,
    'text'
  ]);

  if (title == null) {
    // print('‚ùå No se encontr√≥ t√≠tulo del artista');
    return null;
  }

  // print('üîç Procesando artista: $title');

  // Extraer browseId del artista - buscar en m√∫ltiples ubicaciones
  String? browseId;
  
  // Debug: imprimir estructura del renderer
  // print('üîç Estructura del renderer para $title: ${renderer.keys.toList()}');
  
  // Primero intentar desde el t√≠tulo
  browseId = nav(renderer, [
    'flexColumns',
    0,
    'musicResponsiveListItemFlexColumnRenderer',
    'text',
    'runs',
    0,
    'navigationEndpoint',
    'browseEndpoint',
    'browseId'
  ])?.toString();

  // print('üîç BrowseId desde t√≠tulo: $browseId');

  // Si no est√° ah√≠, buscar en el men√∫
  if (browseId == null) {
    final menuItems = nav(renderer, ['menu', 'menuRenderer', 'items']);
    if (menuItems is List) {
      // print('üîç Buscando en men√∫ con ${menuItems.length} items');
      for (var menuItem in menuItems) {
        final endpoint = nav(menuItem, [
          'menuNavigationItemRenderer',
          'navigationEndpoint',
          'browseEndpoint',
          'browseId'
        ]);
        if (endpoint != null) {
          browseId = endpoint.toString();
            // print('üîç BrowseId encontrado en men√∫: $browseId');
          break;
        }
      }
    }
  }
  
  // Buscar en otras ubicaciones posibles

  // Intentar en la estructura completa del renderer si browseId sigue siendo null
  browseId ??= _findObjectByKey(renderer, 'browseId')?.toString();
  // print('üîç BrowseId desde b√∫squeda recursiva: $browseId');


  // Extraer informaci√≥n adicional (suscriptores, etc.)
  String? subscribers;
  final subtitleRuns = nav(renderer, [
    'flexColumns',
    1,
    'musicResponsiveListItemFlexColumnRenderer',
    'text',
    'runs'
  ]);

  if (subtitleRuns is List && subtitleRuns.isNotEmpty) {
    for (var run in subtitleRuns) {
      final text = run['text'];
      if (text != null && (text.contains('subscriber') || text.contains('suscriptor'))) {
        subscribers = text.split(' ')[0];
        break;
      }
    }
  }

  // Extraer thumbnail - buscar en m√∫ltiples ubicaciones
  String? thumbUrl;
  
  // Primera ubicaci√≥n: thumbnail directo
  var thumbnails = nav(renderer, [
    'thumbnail',
    'musicThumbnailRenderer',
    'thumbnail',
    'thumbnails'
  ]);

  // print('üîç Thumbnails (musicThumbnailRenderer): ${thumbnails != null ? thumbnails.length : 'null'}');

  // Segunda ubicaci√≥n: thumbnail cropped
  thumbnails ??= nav(renderer, [
    'thumbnail',
    'croppedSquareThumbnailRenderer',
    'thumbnail',
    'thumbnails'
  ]);
  // print('üîç Thumbnails (croppedSquareThumbnailRenderer): ${thumbnails != null ? thumbnails.length : 'null'}');

  // Tercera ubicaci√≥n: buscar en cualquier estructura de thumbnail
  if (thumbnails == null) {
    final thumbnail = nav(renderer, ['thumbnail']);
    // print('üîç Estructura de thumbnail completa: ${thumbnail?.keys.toList()}');
    
    // Intentar diferentes estructuras
    if (thumbnail is Map) {
      for (var key in thumbnail.keys) {
        final subThumb = thumbnail[key];
        if (subThumb is Map && subThumb.containsKey('thumbnails')) {
          thumbnails = subThumb['thumbnails'];
          // print('üîç Thumbnails encontrados en $key: ${thumbnails?.length}');
          break;
        }
      }
    }
  }

  if (thumbnails is List && thumbnails.isNotEmpty) {
    // Usar la imagen de mayor resoluci√≥n disponible
    thumbUrl = thumbnails.last['url'];
    // ('‚úÖ Thumbnail encontrado: $thumbUrl');
  } else {
    // print('‚ùå No se encontraron thumbnails para $title');
  }

  return {
    'name': title,
    'browseId': browseId,
    'subscribers': subscribers,
    'thumbUrl': thumbUrl,
  };
}